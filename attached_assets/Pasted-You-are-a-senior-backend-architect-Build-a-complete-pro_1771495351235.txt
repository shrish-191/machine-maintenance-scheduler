You are a senior backend architect.

Build a complete, production-style Machine Maintenance Scheduler web application using Python and FastAPI following proper microservices architecture.

The application must be fully runnable inside Replit without manual restructuring.

============================
PROJECT REQUIREMENTS
============================

Business Scenario:
A manufacturing plant has multiple machines requiring periodic maintenance. The system must manage maintenance scheduling, tracking, and status updates.

Core Functional Requirements:

1) Machine Service
- Create machine
- List all machines
- Get machine by ID
- Update machine
- Delete machine
- Display machine status
- Store maintenance frequency (in days)
- Store last maintenance date
- Automatically calculate next due date

2) Maintenance Service
- Schedule new maintenance task
- View maintenance tasks per machine
- Query upcoming tasks (next 7 days)
- Query overdue tasks
- Mark maintenance as completed
- Store technician name
- Store remarks
- Automatically update machine last_maintenance_date when completed

3) System Features
- Proper input validation
- Error handling
- Status auto-update (Pending / Completed / Overdue)
- Health score per machine:
    completed_tasks / total_tasks * 100

4) Microservices Architecture
- Separate Machine Service
- Separate Maintenance Service
- Each service has:
    - own FastAPI app
    - own database models
    - own router files
    - own database connection

5) Inter-service Communication
- Maintenance service must verify machine existence by calling Machine Service via HTTP request before scheduling task.

6) Database
- Use SQLite for compatibility
- Use SQLAlchemy ORM
- Use Alembic-style clean structure (even if migrations not fully implemented)

Tables Required:

Machine:
- id (UUID)
- name
- location
- status (Running / Stopped / Maintenance)
- maintenance_frequency_days (int)
- last_maintenance_date (date)
- next_due_date (auto calculated)

Maintenance:
- id (UUID)
- machine_id (UUID)
- scheduled_date (date)
- completed_date (nullable)
- status (Pending / Completed / Overdue)
- technician_name (nullable)
- remarks (nullable)

7) Smart Logic
- If scheduled_date < today and not completed → mark as Overdue
- On completion:
    - Update status to Completed
    - Update machine last_maintenance_date
    - Recalculate next_due_date

8) REST APIs

Machine Service Endpoints:
POST /machines
GET /machines
GET /machines/{id}
PUT /machines/{id}
DELETE /machines/{id}
GET /machines/{id}/health

Maintenance Service Endpoints:
POST /maintenance/schedule
GET /maintenance/machine/{machine_id}
GET /maintenance/upcoming
GET /maintenance/overdue
PUT /maintenance/{id}/complete

9) Frontend (Simple but Functional)
- Use Jinja2 templates
- Dashboard page:
    - List machines
    - Show next due date
    - Show health %
    - Color indicators:
        Green → OK
        Yellow → Due in 3 days
        Red → Overdue
- Schedule maintenance form
- Upcoming tasks page

10) Documentation
Auto Swagger UI
Include README.md with:
- Architecture explanation
- How to run
- API examples
- Sample curl commands

11) Project Structure

machine-maintenance/
│
├── machine_service/
│   ├── main.py
│   ├── models.py
│   ├── database.py
│   ├── schemas.py
│   ├── routers/
│
├── maintenance_service/
│   ├── main.py
│   ├── models.py
│   ├── database.py
│   ├── schemas.py
│   ├── routers/
│
├── frontend/
│   ├── main.py
│   ├── templates/
│   ├── static/
│
├── requirements.txt
├── README.md

12) requirements.txt must include:
fastapi
uvicorn
sqlalchemy
pydantic
requests
jinja2

13) App must run with:
uvicorn machine_service.main:app --port 8000
uvicorn maintenance_service.main:app --port 8001
uvicorn frontend.main:app --port 8002

14) Include seed data:
Auto-create 5 sample machines on startup.

15) Ensure everything is cleanly separated and modular.

16) Use UUIDs for IDs.

17) Use dependency injection pattern for DB sessions.

18) Make code production-clean, not beginner style.

19) No placeholder logic. Everything must function correctly.

20) Ensure entire project runs smoothly inside Replit without modification.

Generate full code for all files.

